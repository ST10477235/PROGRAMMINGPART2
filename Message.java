/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.mycompany.poe_assignment_part2;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import javax.swing.JOptionPane;

/**
 *
 * @author VUNINI
 */

//overrides relying on public getters and setters for JSON processing, enables access to all fields, and ensures that all fields are included in the JSON output, even if they donâ€™t have public access modifiers.
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)
public class Message {

    //Attributes
    //add @JsonProperty to instance fields to ensures Jackson properly serializes them
        @JsonProperty("messageId")
        private String messageId;
        @JsonProperty("recipient")
        private String recipient;
        @JsonProperty("messageText")
        private String messageText;
        //Static fields dont need annotation as there are not sterialized in JSON by default 
        private static int totalMessages = 0;
        @JsonProperty("messageNumber")
        private int messageNumber;
        private String createdMessageHash;
        //storing all the messages
        private static List<String>messageList = new ArrayList<>();
     
    //Constructors
    public Message(String recipient)
    {
        this.recipient = recipient;
        this.messageText = "";
        this.messageId = "";
        //adds message to the list
        messageList.add(messageText);
    //Refined my code by removing the if statement that displays "Invalid message Id generated" when it returns to be false 
    }

    // Message class methods 
    
    //I kept the for loop so that i dont repeat "messageId.append(random.nextInt(10))" 9 times 
    String generateMessageId()
    {
        //I created a random instance(new Random)to generate new numbers  
        Random random = new Random();
        //Initiallizing the StringBuilder to store the  generated messageId
        StringBuilder messageId = new StringBuilder();
        messageId.append(random.nextInt(9)+1);//Generates 1-9
        for(int i=1;i<10;i++)
        {
          messageId.append(random.nextInt(10));//Generate 0-9
        }
        System.out.println("Message ID generated: " + messageId);
        // the generated number 0,9,8,7,6,5,4,3,2,1 will be "0987654321"
        return messageId.toString();
    }
    //This method checks if message id is 10 digits long and contains numerical values 
    
    public boolean checkMessageId(String messageId)
    {
        return messageId.length() == 10 && messageId.matches("\\d+");
    }
    //Removed the nested if statement that handles null pointers errors and the cellphone requirements by making it one return statement.This made my methods intend strate forward   
    
    public int checkRecipientCell ()
    {
        //parenthesis play a vey important role here before the second set of parenthesis my program's build would fail if i press "X" when asked to enter recipient number    
        return (recipient != null && (recipient.matches("\\+27\\d{9}")|| recipient.matches("0\\d{9}"))? 1 : 0 );
        //this first checks the and operator as it has higher precedence meaning the or system will first check if its not empty and if not it will check for either a number that starts with +27 or 0 and ensures that number following that are exactly 9 digits       
    }
   
    //Creating and return an autogenerated message hash which has first 2 numbers of message id , the number of messages , the first and last words in the message in uppercases  
    public String createMessageHash(int messageNumber)
    {
       
        String validMessageId = (messageId != null && messageId.length()>=2)?messageId.substring(0, 2):"Invalid";
        String [] words = messageText.split("\\s+");
        String firstWord = (words.length>0)? words [0].toUpperCase():"Empty";
        String lastWord = (words.length>1)?words[words.length-1].toUpperCase(): firstWord;
        createdMessageHash = validMessageId + ":" + messageNumber + ":" + firstWord + lastWord; 
        return createdMessageHash;
    }
    
    //Method to select send , store or discard message removed it from the main program to here and called the method instaed 
    public String sendMessage() {
    String[] buttonOptions = {
        "Send message",
        "Disregard message",
        "Store message to send later"
    };

    String[] responseMessages = {
        "Message sent successfully",
        "Message discarded",
        "Message stored to send later"
    };

    int option = JOptionPane.showOptionDialog(
        null, 
        "What would you like to do with the message?", 
        "Message Option", 
        JOptionPane.DEFAULT_OPTION, 
        JOptionPane.QUESTION_MESSAGE, 
        null, 
        buttonOptions, 
        buttonOptions[0]
    );

   return (option == JOptionPane.CLOSED_OPTION)?null:responseMessages[option]; 
      
    }
   
    //Initially this was my sendMessage method which did not allow the user to make choices then i change the name and still used it to check the length and display appropriate messages depending on the condition 
    public String validateMessageLength(String messageText)//*
    {
        //I then combined the two returns with if statements using ? and : to check the messages validation 
        return messageText.length()>250 ? "Please enter message of less than 250 characters":"Message sent successfully";
    }
    
    //This method returns a list of all the messages
    public static List<String> printMessages()
    {
        List<String>sentMessages = new ArrayList<>();
        return sentMessages;
    }
    
    //Displays the full detailes regarding the message this includes the message id , hash , actual text and the person who will recieve that message  
    public String printFullDetails(int messageNumber)//*
    {
        messageNumber++;
        return "Message ID:"+messageId
                +"\n Message Hash:"+createMessageHash(messageNumber)//calling the method hence its not a keyword because its not a field rather a method i created  
                +"\nRecipient:"+recipient 
                +"\nMessage:"+messageText;
    }
    
    //This method is to ensure that the total number of messages sent is returned , without this method there will be errors so returning , incrementing and reseting the total messages is very efficient to avoid logical errors  
    public static int returnTotalMessages()
    {
       return totalMessages;
    }
   
    //Total messages sent are acumulated in this case when you're about to send a message since its set to 0 when you send it will be 1 everytime a message is send the it counts from the initial value to the end 
    public static void incrementTotalMessages() 
    {
       totalMessages++;
    }
    
    //without this method when i run my code the first time it would be correct but the second time it will display total number including the first one hence i had to create a variable to reset it every time when i am done entering messages  
    public static void resetTotalMessages()
    {
      totalMessages = 0;
    }
    //Method to store the messages in a JSON file 
    //When i run the program without the annotation it will display a long error message about no sterilization
    
    public void storeMessage(String fileName)throws IOException
    {
        ObjectMapper mapper = new ObjectMapper();
    File file = new File(fileName);

    ArrayNode messagesArray;

    if (file.exists() && file.length() > 0) {
        JsonNode rootNode = mapper.readTree(file);
        
        // Ensure "messages" exists and is an array
        if (rootNode.has("messages") && rootNode.get("messages").isArray()) {
            messagesArray = (ArrayNode) rootNode.get("messages");
        } else {
            messagesArray = mapper.createArrayNode(); // Initialize if missing
        }
    } else {
        messagesArray = mapper.createArrayNode(); // Initialize for a new file
    }

    // Create new message object
    ObjectNode newMessage = mapper.createObjectNode();
    newMessage.put("messageId", "1");
    newMessage.put("recipient", "0987765432");
    newMessage.put("messageText", "Hello!");
    newMessage.put("messageNumber", 1);
    newMessage.put("createdMessageHash", "abc123");

    // Add new message to array
    messagesArray.add(newMessage);

    // Create final JSON structure
    ObjectNode finalJson = mapper.createObjectNode();
    finalJson.set("messages", messagesArray);

    // Write updated JSON back to file
    mapper.writeValue(file, finalJson);

    //Jackson's ObjectMapper is broadly used for handling JSON serialization and deserialization in Java. According to Baeldung, "ObjectMapper is the main class for working with JSON in the Jackson library. It provides methods to convert Java objects to JSON and vice versa with minimal configuration." (Baeldung, 2023).
    //Similarly, Stack Abuse explains that "ObjectMapper simplifies JSON processing by automatically mapping Java objects to structured JSON data, supporting various formats and customization options." (Stack Abuse, 2023).
    }

    
    //Setters and Getters 
    public String getMessageId(){
        return messageId;
    }
    public String getRecipient(){
        return recipient;
    }
    public String getMessageText(){
        return messageText;
    }
    public String getCreatedMessageHash()
    {
        return createdMessageHash;
    }
    public void setMessageText(String messageText) 
    {
        this.messageText = messageText;

        if (!messageText.isEmpty()&& messageId.isEmpty()) {
            this.messageId = generateMessageId(); // Generate ID only after message text is entered
        }
    }
    void setMessageId(String string) 
    {
     
    }
    //Usefull in unit testing  
    Message() 
    {
     
    }
}
    

